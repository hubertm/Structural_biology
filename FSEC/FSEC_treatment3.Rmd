---
title: "Integration of FSEC peaks using R"
output: html_document
---

This tutorial explains how to use R to analyse FSEC / tFSEC curves. The same analysis can be done manually using Chromelab - and depending on the number this could even be shorter! Also, *looking* at the shapes of the chromatograms is an obvious advantage of manual treatment over scripted treatment. Still using scripts and a programmation language will have some interest for repetitive experiments when peaks are well-defined.

## Foreplays: export data and cleansing of the header

On the machineâ€™s computer, open simultaneously the runs in Chromelab. *Do not* play with the visible curves and export in cvs format. If you process a lot of runs you're likely to obtain a huge file. Here the file cointaining the 32 runs weight about 50 Mo. Alternatively, you can choose to untick all curves but the fluo ones (that means 96 unticking+scrolling in this case... awful, but can be quick if you work with just a few runs).

Most of the data we are not interested in, and the first thing to do is to throw away all curves (A280, Conductivity, %B) but the fluo ones. To do this you need to keep only the 7th,8th,15th,16th,23th,24th,etc... columns in your data. The (8n-1)th columns contain volumes, the (8n)th columns contains fluorescence values.

This is done with **in a shell terminal** with the command

cut -d ',' -f 3,4,7,8,11,12,15,16,19,20,23,24,27,28,31,32,35,36,39,40,43,44,47,48,51,52,55,56,59,60,63,64,67,68,71,72,75,76,79,80,83,84 150220_Rt-1-1_S200_Increase_diff_detergents.csv > toto.csv


Here the *looong* list of columns to keep was generated with a *for* loop in R.

```{r}
liste = NULL
for (n in 1:20)
{
   liste[2*n-1] <- 4*n-1
   liste[2*n] <- 4*n
}
cat (liste, sep=", ")
```

It's not done yet. The data is incomplete, which means there are missing values for some columns, especially at the end of the file (15282 lines in *Hubert1.cvs*). And it has two crappy lines at the top, a header that R does not easily read.

So we remove the first 500 lines, and the last 5000 ones, using the shell terminal. Don't ask me how these two command works, I found them on the web. The number of lines to remove is an arbitrary choice, here I looked at the end of the file removing more and more lines until I saw no more missing values (they appear as multiples commas). Note that this tedious part can be skipped if you are clever enough to overlay the curves in Chromelab and then zoom to a *good* zoom and use the option to save only the visible data.

###In BASH  
#####Under Linux at least it works. Mac OS X uses a different flavour of sed and has a different syntax):
~~~~~~~~~~
sed -n 1p toto.csv>line1
for i in {1..20}
do
cut -d ',' -f $((i*2)) line1 >>tmp.csv
echo $i >>tmp.csv
done
sed -i 's/\s//g' tmp.csv 
rm line1
#remove the newlines
sed ':a;N;$!ba;s/\n/,/g' tmp1.csv > processed.csv
rm tmp*

sed -i -e 1,2d toto.csv
#-i replaces the original file -e adds the script to the commands to be executed
#The command removes the first 2 lines

sed -e :a -e '$d;N;2,5ba' -e 'P;D' toto.csv > tmpfile ; mv tmpfile toto.csv
#Removes the last 5 lines
cat toto.csv>>processed.csv
rm toto.csv
#To check the number of the lines (Bash)
------
wc -l toto.cvs 
~~~~~~~~~~

## Import of the data and data structure

Now you can read in R the .csv file

```{r}
fluo=read.csv("toto.csv")
```

The variable fluo is a kind of table. It contains `2n` sub-variables that are the volumes and fluorescence values for each run. In R studio you can see the structure of the variable on the top right panel. In the console, you can access to one subvariable using its column number starting from 1, e.g. 5 is the volume for run 3, 6 is the fluo for run 3.

## Peak integration and baseline substraction

As we need a function to calculate the area under the curve that is not installed by default in R, let's load the library MESS that contains the function `auc` (Area Under Curve). If you're never used this library it first needs to be installed with the function

#```{r,eval=FALSE}
#install.packages("MESS")
#```

```{r}
library("MESS")
```

The syntax of this function is ultra-simple, you provide a set of points for x and y, and eventually border in x for the integration

```{r}
auc(fluo[,1],fluo[,2])
auc(fluo[,1],fluo[,2],12,13)
```

One caveat is that the curves do not have a zero baseline, therefore the result of the peak integration is not correct (I get 557). We can substract the mean of the first milliliters of the run (here the first 5 mL), that should be a good approximate of the baseline. Let's do that for the first run and store the result in a new object called *fluo_baseline*

```{r}
fluo_baseline <- fluo[,2] - mean(fluo[,2][fluo[,1]<5])
```

Now the auc function should give the proper results

```{r}
auc(fluo[,1],fluo_baseline,12,13)
```

The baseline substraction need to be applied to all runs in the dataset. We can use a *for* loop to do that, replacing each fluorescence data by its value minus the baseline. The fluorescence data are in the even columns, so let's modify only the columns *2n* when *n* varies from 1 to half of the number of runs.

```{r}
for (n in 1:(length(fluo)/2) )
  {
  fluo[2*n] <- fluo[2*n] - mean(fluo[2*n][fluo[2*n-1]<5])
  }
```

*Note* This piece of code works only if there are no missing values by zeros, hence the foreplay section.

Now if you replot the curve for the first sample, you can see the baseline has gone from about 100 to about 0

```{r, echo=TRUE}
for (n in 1:(length(fluo)/2) )
  {
  plot(fluo[,2*n-1],fluo[,2*n],type="l",col="green", main = names(fluo[n*2-1]), xlab = "ml", ylab = "mV")
  }
```
#The comma in the plot before the index of what is to be plotted is need (plot(fluo[,2*n-1]) as fluo is a data.frame but plot wants a vector. One can also transpose it to plot things.
## Construction of the comparison plot for all runs

Let's create a new vector of *n* values (the number of runs) containing the integrated values for each run. This is done once again with a *for* loop.

```{r}
peak = NULL
for (n in 1:(length(fluo)/2) )
{
  peak[n] <- auc(fluo[,2*n-1],fluo[,2*n],12,13)
}
```

*Note* Before being used in a loop, variable needs to exist, hence the *peak = NULL* line.

Ok, we're done, the histogram of the values under the curve for all runs can now be drawn

```{r}
barplot(peak)
```

Just for comparison, we can use the peak height instead of the area under the curve

```{r}
height = NULL
for (n in 1:(length(fluo)/2) )
{
  height[n] <- max(fluo[,2*n][fluo[,2*n-1]>12 & fluo[,2*n-1]<13])
}
barplot(height)
```
ADDITION
read.csv reads the data as character. This will transform it into the type double
```{r}
test<-data.matrix(fluo[1:2])
```

